"""OnlyKey-related code (see https://www.onlykey.io/)."""

import binascii
import base64
import io
import logging
import re
import hashlib
import codecs
import struct
import sys
import unidecode

from . import interface
from .. import formats, util

import ecdsa
import nacl.signing
import time

log = logging.getLogger(__name__)

class OnlyKey(interface.Device):
    """Connection to OnlyKey device."""

    @classmethod
    def package_name(cls):
        """Python package name (at PyPI)."""
        return 'onlykey-agent'

    @property
    def _defs(self):
        from . import onlykey_defs
        return onlykey_defs

    def skey(self, skey):
        self.skeyslot = skey

    def dkey(self, dkey):
        self.dkeyslot = dkey

    def connect(self):
        """Enumerate and connect to the first USB HID interface."""
        try:
            self.device_name = 'OnlyKey'
            self.ok = self._defs.OnlyKey()
        except :
            raise interface.NotFoundError(
                '{} not connected: "{}"')

    def close(self):
        """Close connection."""
        log.info('disconnected from %s', self.device_name)
        self.ok.close()

    def oclose(self):
        """Close connection."""
        log.info('disconnected from %s', self)

    def pubkey(self, identity, ecdh=False, rsa=False):
        curve_name = identity.get_curve_name(ecdh=ecdh)

        if hasattr(self, 'skeyslot'):
            if (ecdh==True):
                this_slot_id=self.dkeyslot
            else:
                this_slot_id=self.skeyslot
        else:
            this_slot_id=132

        log.debug('"%s" getting public key (%s) from %s',
                  identity.to_string(), curve_name, self)

        # Compute the challenge pin from identity
        h1 = hashlib.sha256()
        h1.update(identity.to_bytes())
        data = h1.hexdigest()

        log.info('Identity hash =%s', data)

        log.info('Key slot =%s', this_slot_id)

        if curve_name == 'curve25519':
            data = '04' + data
        elif curve_name == 'secp256k1':
            # Not currently supported by agent, for future use
            data = '03' + data
        elif curve_name == 'nist256p1':
            data = '02' + data
        elif curve_name == 'ed25519':
            data = '01'+ data
        elif curve_name == 'rsa':
            data = '00'+ data

        self.ok.send_message(msg=self._defs.Message.OKGETPUBKEY, slot_id=this_slot_id, payload=data)
        t_end = time.time() + 2
        while time.time() < t_end:
            try:
                ok_pubkey = self.ok.read_bytes(timeout_ms=100)
                if len(ok_pubkey) == 64 and len(set(ok_pubkey[0:63])) != 1:
                    break
            except Exception as e:
                raise interface.DeviceError(e)
                return

        log.info('received= %s', repr(ok_pubkey))

        if  len(set(ok_pubkey[34:63])) == 1:
            ok_pubkey = bytearray(ok_pubkey[0:32])
            log.info('Received Public Key generated by OnlyKey= %s', repr(ok_pubkey.hex()))
            vk = nacl.signing.VerifyKey(bytes(ok_pubkey),
                                    encoder=nacl.encoding.RawEncoder)
            return vk
        elif len(ok_pubkey) == 64:
            ok_pubkey = bytearray(ok_pubkey[0:64])
            log.info('Received Public Key generated by OnlyKey= %s', repr(ok_pubkey))
            if identity.curve_name == 'nist256p1':
                vk = ecdsa.VerifyingKey.from_string(ok_pubkey, curve=ecdsa.NIST256p)
            else:
                vk = ecdsa.VerifyingKey.from_string(ok_pubkey, curve=ecdsa.SECP256k1)
            return vk
        else:
            raise interface.DeviceError("Error response length is not a valid public key")

    def sign(self, identity, blob):
        """Sign given blob and return the signature (as bytes)."""
        curve_name = identity.get_curve_name(ecdh=False)
        log.debug('"%s" signing %r (%s) on %s',
                  identity.to_string(), blob, curve_name, self)

        # Compute the challenge pin from identity
        h1 = hashlib.sha256()
        h1.update(identity.to_bytes())
        data = h1.hexdigest()
        data = codecs.decode(data, 'hex_codec')

        log.info('data hash =%s', data)
        raw_message = blob + data
        h2 = hashlib.sha256()
        h2.update(raw_message)
        d = h2.digest()
        assert len(d) == 32

        def get_button(byte):
            return byte % 6 + 1

        b1, b2, b3 = get_button(d[0]), get_button(d[15]), get_button(d[31])

        if (self.skeyslot==132):
        # Determine type of key to derive on OnlyKey for signature
            if curve_name == 'ed25519':
                this_slot_id = 201
                log.info('Key type ed25519')
            elif curve_name == 'nist256p1':
                this_slot_id = 202
                log.info('Key type nistp256')
            else:
                this_slot_id = 203
                log.info('Key type secp256k1')
        else:
            this_slot_id = self.skeyslot

        self.ok.send_large_message2(msg=self._defs.Message.OKSIGN, payload=raw_message, slot_id=this_slot_id)


        print ('"%s" signing %r (%s) on %s',
                  identity.to_string(), blob, curve_name, self)
        print ('Enter the 3 digit challenge code on OnlyKey to authorize')
        print ('{} {} {}'.format(b1, b2, b3))

        t_end = time.time() + 22
        while time.time() < t_end:
            try:
                result = self.ok.read_bytes(timeout_ms=100)
                if len(result) == 64 and len(set(result[0:63])) != 1:
                    break
            except Exception as e:
                raise interface.DeviceError(e)
                return


        if len(result) >= 60:
            log.info('received= %s', repr(result))
            while len(result) < 64:
                result.append(0)
            log.info('disconnected from %s', self.device_name)
            self.ok.close()
            return bytes(result)

        raise Exception('failed to sign challenge')


    def ecdh(self, identity, pubkey):
        """Get shared session key using Elliptic Curve Diffie-Hellman."""
        curve_name = identity.get_curve_name(ecdh=True)
        log.debug('"%s" shared session key (%s) for %r from %s',
                  identity.to_string(), curve_name, pubkey, self)

        # Compute the challenge pin from identity
        h1 = hashlib.sha256()
        h1.update(identity.to_bytes())
        data = h1.hexdigest()
        data = codecs.decode(data, 'hex_codec')

        log.info('data hash =%s', data)
        raw_message = pubkey + data
        h2 = hashlib.sha256()
        h2.update(raw_message)
        d = h2.digest()
        assert len(d) == 32

        def get_button(byte):
            return byte % 6 + 1

        b1, b2, b3 = get_button(d[0]), get_button(d[15]), get_button(d[31])

        log.info('blob to send', repr(raw_message))

        if (self.dkeyslot==132):
            # Determine type of key to derive on OnlyKey for signature
            if identity.curve_name == 'curve25519':
                this_slot_id = 204
            elif identity.curve_name == 'nist256p1':
                this_slot_id = 202
            else:
                this_slot_id = 203
        else:
            this_slot_id = self.dkeyslot

        self.ok.send_large_message2(msg=self._defs.Message.OKDECRYPT, payload=raw_message, slot_id=this_slot_id)

        print ('"%s" shared session key (%s) for %r from %s',
                  identity.to_string(), curve_name, pubkey, self)
        print ('Enter the 3 digit challenge code on OnlyKey to authorize')
        print ('{} {} {}'.format(b1, b2, b3))


        t_end = time.time() + 22
        while time.time() < t_end:
            try:
                result = self.ok.read_bytes(timeout_ms=100)
                if len(result) == 64 and len(set(result[0:63])) != 1:
                    break
            except Exception as e:
                raise interface.DeviceError(e)
                return


        log.info('received= %s', repr(result))
        log.info('disconnected from %s', self.device_name)
        self.ok.close()

        if  len(set(result[34:63])) == 1:
            result = b'\x04' + bytes(result[0:32])

        return bytes(result)

        raise Exception('failed to generate shared session key')


_identity_regexp = re.compile(''.join([
    '^'
    r'(?:(?P<proto>.*)://)?',
    r'(?:(?P<user>.*)@)?',
    r'(?P<host>.*?)',
    r'(?::(?P<port>\w*))?',
    r'(?P<path>/.*)?',
    '$'
]))

def string_to_identity(s, identity_type=dict):
    """Parse string into Identity protobuf."""
    m = _identity_regexp.match(s)
    result = m.groupdict()
    log.debug('parsed identity: %s', result)
    kwargs = {k: v for k, v in result.items() if v}
    return identity_type(**kwargs)

def _parse_ssh_blob(data):
    res = {}
    i = io.BytesIO(data)
    res['nonce'] = util.read_frame(i)
    i.read(1)  # SSH2_MSG_USERAUTH_REQUEST == 50 (from ssh2.h, line 108)
    res['user'] = util.read_frame(i)
    res['conn'] = util.read_frame(i)
    res['auth'] = util.read_frame(i)
    i.read(1)  # have_sig == 1 (from sshconnect2.c, line 1056)
    res['key_type'] = util.read_frame(i)
    public_key = util.read_frame(i)
    res['public_key'] = formats.parse_pubkey(public_key)
    assert not i.read()
    return res

def bytes2num(s):
    """Convert MSB-first bytes to an unsigned integer."""
    res = 0
    for i, c in enumerate(reversed(bytearray(s))):
        res += c << (i * 8)
    return res

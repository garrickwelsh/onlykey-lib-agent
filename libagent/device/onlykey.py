"""OnlyKey-related code (see https://www.onlykey.io/)."""

import binascii
import base64
import io
import logging
import re
import hashlib
import codecs
import struct
import sys

from . import interface

import ecdsa
import ed25519
import time

log = logging.getLogger(__name__)


class OnlyKey(interface.Device):
    """Connection to OnlyKey device."""

    @classmethod
    def package_name(cls):
        """Python package name (at PyPI)."""
        return 'onlykey-agent'

    @property
    def _defs(self):
        from . import onlykey_defs
        return onlykey_defs

    def connect(self):
        """Enumerate and connect to the first USB HID interface."""
        try:
            self.device_name = 'OnlyKey'
            self.ok = self._defs.OnlyKey()
        except :
            raise interface.NotFoundError(
                '{} not connected: "{}"')

    def close(self):
        """Close connection."""
        log.info('disconnected from %s', self.device_name)
        self.ok.close()

    def pubkey(self, identity, ecdh=False):
        log.info('getting public key from %s...', self.device_name)
        log.info('Trying to read the public key...')
        # Compute the challenge pin
        h = hashlib.sha256()
        h.update(identity.to_bytes())
        data = h.hexdigest()

        log.info('Identity hash =%s', data)

        if identity.curve_name == 'secp256k1':
            # Not currently supported by agent, for future use
            data = '03' + data
        elif identity.curve_name == 'nist256p1':
            data = '02' + data
        else:
            data = '01'+ data

        log.info('Identity hash =%s', data)
        self.ok.send_message(msg=self._defs.Message.OKGETPUBKEY, slot_id=132, payload=data)
        time.sleep(.5)
        for _ in range(3):
            try:
                ok_pubkey = self.ok.read_bytes()
            except:
                raise interface.DeviceError("OnlyKey is locked, enter PIN to unlock")
                return
            if len(ok_pubkey) == 64:
                break

        log.info('received= %s', repr(ok_pubkey))

        if  len(set(ok_pubkey[34:63])) == 1:
            ok_pubkey = bytearray(ok_pubkey[0:32])
            log.info('Received Public Key generated by OnlyKey= %s', repr(ok_pubkey.hex()))
            vk = ed25519.VerifyingKey(ok_pubkey.hex(), encoding="hex")
            log.info('vk= %s', repr(vk))
            return vk
        elif len(ok_pubkey) == 64:
            ok_pubkey = bytearray(ok_pubkey[0:64])
            log.info('Received Public Key generated by OnlyKey= %s', repr(ok_pubkey))
            if identity.curve_name == 'nist256p1':
                vk = ecdsa.VerifyingKey.from_string(ok_pubkey, curve=ecdsa.NIST256p)
            else:
                vk = ecdsa.VerifyingKey.from_string(ok_pubkey, curve=ecdsa.SECP256k1)
            log.info('vk= %s', repr(vk))
            return vk
        else:
            raise interface.DeviceError("Error response length is not a valid public key")


    def sign(self, identity, blob):
        """Sign given blob and return the signature (as bytes)."""
        curve_name = identity.get_curve_name(ecdh=False)
        log.debug('"%s" signing %r (%s) on %s',
                  identity.to_string(), blob, curve_name, self)

        h1 = hashlib.sha256()
        h1.update(identity.to_bytes())
        data = h1.hexdigest()
        data = codecs.decode(data, 'hex_codec')

        log.info('Identity hash =%s', data)

        test_payload = blob + data
        # Compute the challenge pin
        h2 = hashlib.sha256()
        h2.update(test_payload)
        d = h2.digest()
        assert len(d) == 32

        def get_button(byte):
            return byte % 6 + 1

        b1, b2, b3 = get_button(d[0]), get_button(d[15]), get_button(d[31])

        log.info('blob to send', repr(test_payload))

        # Determine type of key to derive on OnlyKey for signature
        # 201 = ed25519
        # 202 = P256
        # 203 = secp256k1
        if curve_name == 'ed25519':
            this_slot_id = 201
            log.info('Key type ed25519')
        elif curve_name == 'nist256p1':
            this_slot_id = 202
            log.info('Key type nistp256')
        else:
            this_slot_id = 203
            log.info('Key type secp256k1')

        self.ok.send_large_message2(msg=self._defs.Message.OKSIGN, payload=test_payload, slot_id=this_slot_id)


        print ('"%s" signing %r (%s) on %s',
                  identity.to_string(), blob, curve_name, self)
        print ('Enter the 3 digit challenge code on OnlyKey to authorize')
        print ('{} {} {}'.format(b1, b2, b3))
        #TODO ping messages so that we don't need enter key to tell when done.
        time.sleep(10)
        for _ in range(10):
            try:
                result = self.ok.read_bytes(64, to_str=True, timeout_ms=200)
            except:
                raise interface.DeviceError("Error incorrect challenge was entered")
                return
            if len(result) >= 60:
                log.info('received= %s', repr(result))
                while len(result) < 64:
                    result.append(0)
                log.info('disconnected from %s', self.device_name)
                self.ok.close()
                return result

        raise Exception('failed to sign challenge')

    def ecdh(self, identity, pubkey):
        """Get shared session key using Elliptic Curve Diffie-Hellman."""
        curve_name = identity.get_curve_name(ecdh=True)
        log.debug('"%s" shared session key (%s) for %r from %s',
                  identity.to_string(), curve_name, pubkey, self)

        h1 = hashlib.sha256()
        h.update(identity.to_bytes())
        data = h.hexdigest()

        log.info('Identity hash =%s', data)

        test_payload = blob + data
        # Compute the challenge pin
        h2 = hashlib.sha256()
        h2.update(test_payload)
        d = h2.digest()
        assert len(d) == 32

        def get_button(byte):
            ibyte = ord(byte)
            return ibyte % 6 + 1

        b1, b2, b3 = get_button(d[0]), get_button(d[15]), get_button(d[31])

        log.info('blob to send', repr(test_payload))

        # Determine type of key to derive on OnlyKey for signature
        # 201 = ed25519
        # 202 = P256
        # 203 = secp256k1
        if identity.curve_name == 'ed25519':
            this_slot_id = 201
            log.info('Key type ed25519')
        elif identity.curve_name == 'nist256p1':
            this_slot_id = 202
            log.info('Key type nist256p1')
        else:
            this_slot_id = 203
            log.info('Key type secp256k1')

        self.ok.send_large_message2(msg=self._defs.Message.OKDECRYPT, payload=test_payload, slot_id=this_slot_id)


        print ('Please confirm user', msg['user'], 'login to', identity, 'using', self.device_name)
        print ('Enter the 3 digit challenge code on OnlyKey to authorize')
        print ('{} {} {}'.format(b1, b2, b3))
        #TODO ping messages so that we don't need enter key to tell when done.
        time.sleep(10)
        for _ in range(10):
            try:
                result = self.ok.read_bytes(64, to_str=True, timeout_ms=200)
            except:
                raise interface.DeviceError("Error incorrect challenge was entered")
                return

            if len(result) >= 32:
                log.info('received= %s', repr(result))
                log.info('disconnected from %s', self.device_name)
                self.ok.close()
                return result

        raise Exception('failed to generate shared session key')


_identity_regexp = re.compile(''.join([
    '^'
    r'(?:(?P<proto>.*)://)?',
    r'(?:(?P<user>.*)@)?',
    r'(?P<host>.*?)',
    r'(?::(?P<port>\w*))?',
    r'(?P<path>/.*)?',
    '$'
]))

def string_to_identity(s, identity_type=dict):
    """Parse string into Identity protobuf."""
    m = _identity_regexp.match(s)
    result = m.groupdict()
    log.debug('parsed identity: %s', result)
    kwargs = {k: v for k, v in result.items() if v}
    return identity_type(**kwargs)

def _parse_ssh_blob(data):
    res = {}
    i = io.BytesIO(data)
    res['nonce'] = util.read_frame(i)
    i.read(1)  # SSH2_MSG_USERAUTH_REQUEST == 50 (from ssh2.h, line 108)
    res['user'] = util.read_frame(i)
    res['conn'] = util.read_frame(i)
    res['auth'] = util.read_frame(i)
    i.read(1)  # have_sig == 1 (from sshconnect2.c, line 1056)
    res['key_type'] = util.read_frame(i)
    public_key = util.read_frame(i)
    res['public_key'] = formats.parse_pubkey(public_key)
    assert not i.read()
    return res
